# BioCage

[![Release](https://img.shields.io/github/v/release/biocypher/biocage)](https://img.shields.io/github/v/release/biocypher/biocage)
[![Build status](https://img.shields.io/github/actions/workflow/status/biocypher/biocage/main.yml?branch=main)](https://github.com/biocypher/biocage/actions/workflows/main.yml?query=branch%3Amain)
[![Commit activity](https://img.shields.io/github/commit-activity/m/biocypher/biocage)](https://img.shields.io/github/commit-activity/m/biocypher/biocage)
[![License](https://img.shields.io/github/license/biocypher/biocage)](https://img.shields.io/github/license/biocypher/biocage)

**BioCage** is a fast, secure, and practical Python sandbox designed specifically for safely executing code generated by Large Language Models (LLMs). It provides a robust containerized environment that isolates code execution while maintaining high performance and ease of use.

## üéØ Purpose

When working with LLMs that generate Python code, safety and reliability are paramount. BioCage addresses the critical need for:

- **Safe execution** of untrusted code generated by AI models
- **Isolated environment** that prevents system contamination
- **Consistent runtime** with pre-installed dependencies
- **Structured output** with proper error handling and JSON responses
- **Resource management** with execution timeouts and limits

## ‚ú® Key Features

### üîí Security First
- **Complete isolation** through Docker containerization
- **No network access** during code execution
- **Restricted file system** access
- **Safe execution** of potentially malicious code

### ‚ö° Performance Optimized
- **Fast startup times** with optimized container images
- **Minimal overhead** for code execution
- **Efficient resource usage** with proper limits
- **Quick build process** with caching strategies

### üõ†Ô∏è Developer Friendly
- **Simple API** for code execution
- **Structured JSON output** for easy parsing
- **Comprehensive error handling** with detailed diagnostics
- **Multiple input methods** (stdin, environment variables)
- **Pre-installed dependencies** (NumPy, Pandas, and more)

### üîß Flexible Integration
- **Easy Docker deployment** with automated builds
- **Environment variable support** for dynamic code execution
- **Configurable timeouts** and resource limits
- **Extensible dependency management** through pyproject.toml
- **File system exposure** for data processing workflows
- **State persistence** across multiple executions
- **Context manager support** for automatic resource cleanup

## üöÄ Quick Start

### Basic Usage

#### Using the Python API

```python
from biocage import BioCageManager

# Simple execution
with BioCageManager() as sandbox:
    result = sandbox.run('print("Hello from BioCage!")')
    print(result.stdout)  # "Hello from BioCage!"
```

#### Persistent Sessions with State

```python
# Start a persistent container for multiple executions
sandbox = BioCageManager()
sandbox.start_container()

# Execute code with state persistence
result1 = sandbox.run('x = 42')
result2 = sandbox.run('print(f"x = {x}")')  # Remembers x from previous execution
print(result2.stdout)  # "x = 42"

sandbox.stop_container()
```

#### File and Directory Exposure

```python
# Expose files and directories to the sandbox
with BioCageManager().configure_context_manager(
    expose_files={"/path/to/data.csv": "/app/shared/data.csv"},
    expose_directories={"/path/to/models": "/app/shared/models"},
    expose_directories_rw={"./output": "/app/output"}
) as sandbox:
    result = sandbox.run("""
import pandas as pd
data = pd.read_csv('/app/shared/data.csv')
print(f"Loaded {len(data)} rows")

# Save results to output directory
with open('/app/output/results.txt', 'w') as f:
    f.write(f"Processed {len(data)} rows")
""")
```

### Working with Dependencies

BioCage comes with popular data science libraries pre-installed:

```python
from biocage import BioCageManager

with BioCageManager() as sandbox:
    result = sandbox.run("""
import numpy as np
import pandas as pd

# NumPy operations
arr = np.array([1, 2, 3, 4, 5])
print(f"Array mean: {np.mean(arr)}")

# Pandas operations
df = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]})
print(f"DataFrame shape: {df.shape}")
""")
    print(result.stdout)
```

### Advanced Features

#### State Persistence Between Executions

```python
# Variables, functions, and imports persist across executions
sandbox = BioCageManager()
sandbox.start_container()

# Define a function
sandbox.run("""
def calculate_fibonacci(n):
    if n <= 1:
        return n
    return calculate_fibonacci(n-1) + calculate_fibonacci(n-2)
""")

# Use the function in subsequent execution
result = sandbox.run("print(f'Fibonacci(10) = {calculate_fibonacci(10)}')")
print(result.stdout)  # "Fibonacci(10) = 55"

sandbox.stop_container()
```

#### Resource Management and Security

```python
# Configure container resources
sandbox = BioCageManager()
sandbox.start_container(
    memory_limit="2g",
    cpu_limit="4.0",
    network_access=False  # Disabled by default for security
)

# Automatic failure handling and container shutdown
result = sandbox.run("print(undefined_variable)", shutdown_on_failure=True)
print(result.success)  # False - container automatically stopped
```

#### Temporary File Creation

```python
with BioCageManager() as sandbox:
    # Create temporary files accessible in the container
    csv_data = "name,age\nAlice,30\nBob,25"
    csv_path = sandbox.create_temp_file(csv_data, suffix=".csv")
    
    result = sandbox.run(f"""
import pandas as pd
df = pd.read_csv('{csv_path}')
print(f"Loaded data: {len(df)} rows")
print(df.to_string())
""")
    print(result.stdout)
    # Temporary files cleaned up automatically
```

### Direct Docker Usage

You can also use the Docker container directly:

```bash
# Execute via stdin
echo 'print("Hello from BioCage!")' | docker run --rm -i biocage:latest

# Execute via environment variable
docker run --rm -e PYTHON_CODE="print('Hello World!')" biocage:latest
```

## üìã Output Format

All executions return a `SandboxExecutionResult` object with the following attributes:

- **stdout**: Standard output from the executed code
- **stderr**: Error messages and warnings  
- **exit_code**: Execution result status
- **execution_time**: Time taken to execute the code
- **error**: Detailed error information when applicable
- **success**: Boolean indicating if execution was successful

Example usage:
```python
from biocage import BioCageManager

with BioCageManager() as sandbox:
    result = sandbox.run('print("Hello from BioCage!")')
    
    print(f"Success: {result.success}")
    print(f"Output: {result.stdout}")
    print(f"Execution time: {result.execution_time:.3f}s")
    
    # Convert to dictionary if needed
    result_dict = result.to_dict()
```

Example result dictionary:
```json
{
  "stdout": "Hello from BioCage!\n",
  "stderr": "",
  "exit_code": 0,
  "execution_time": 0.045,
  "error": null,
  "success": true
}
```

## üèóÔ∏è Architecture

BioCage is built with a clean architecture that separates concerns:

- **BioCageManager** (`biocage/biocage_manager.py`): Main class for container lifecycle management and code execution
- **SandboxExecutionResult** (`biocage/biocage_manager.py`): Result container with execution metadata
- **Docker Environment** (`python_docker/`): Containerized execution environment with security hardening
- **Build System**: Automated image building and dependency management
- **State Persistence**: Session state management for multi-execution workflows

### Key Components

#### BioCageManager
- Container lifecycle management (start/stop/restart)
- File and directory exposure to containers
- Persistent and ephemeral execution modes
- Resource management (memory, CPU, timeouts)
- Security enforcement (network isolation, read-only filesystem)

#### Execution Modes
- **Ephemeral**: Single-use containers for isolated execution
- **Persistent**: Long-running containers with state preservation between executions
- **Context Manager**: Automatic resource cleanup with `with` statements

## üéØ Use Cases

### LLM Integration
Perfect for integrating with AI coding assistants, chatbots, and automated code generation systems that need to execute Python code safely.

### Educational Platforms
Ideal for online learning platforms that need to run student-submitted code in a secure environment.

### Code Validation
Excellent for automated testing and validation of generated code snippets.

### Research & Development
Great for researchers working with AI-generated code who need reliable execution environments.

## üõ°Ô∏è Security Considerations

BioCage is designed with security as a first-class concern:

- **Containerized execution** prevents access to the host system
- **No network access** during code execution
- **Resource limits** prevent resource exhaustion attacks
- **Timeout controls** prevent infinite loops
- **Isolated file system** prevents data leakage

## üìö Documentation

- [BioCageManager Features & Usage](biocagemanager-features.md) - Comprehensive guide to advanced sandbox features
- [Docker Image Setup](docker-setup.md) - Complete guide for building and configuring the Docker environment
- [API Reference](modules.md) - Detailed API documentation
- [Contributing Guide](https://github.com/biocypher/biocage/blob/main/CONTRIBUTING.md) - How to contribute to the project

## üîó Links

- **GitHub Repository**: [https://github.com/biocypher/biocage/](https://github.com/biocypher/biocage/)
- **PyPI Package**: [https://pypi.org/project/BioCage/](https://pypi.org/project/BioCage/)
- **Issues & Support**: [https://github.com/biocypher/biocage/issues](https://github.com/biocypher/biocage/issues)

---

*BioCage: Safe, fast, and reliable Python code execution for the AI era.*
